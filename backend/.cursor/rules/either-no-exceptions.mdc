---
description: Either No Exceptions Rule
alwaysApply: false
---
# Either No Exceptions Rule

## 규칙 이름
`either-no-exceptions`

## 설명
메서드의 리턴 타입이 `Either<Failure, T>`인 경우, 해당 메서드는 **어떤 예외(Exception)도 던지지 않아야** 합니다. `IllegalArgumentException`, `NullPointerException` 등을 포함한 모든 오류 상황은 `Either.left(Failure)`로 처리해야 합니다.

## 세부 규칙

### 1. 예외 금지
- `Either<Failure, T>` 리턴 타입을 가진 메서드는 `throws` 선언을 하지 않습니다
- `throw new Exception()` 구문을 사용하지 않습니다
- `IllegalArgumentException`, `NullPointerException` 등 프로그래밍 오류도 예외로 던지지 않습니다

### 2. 오류 처리 방식
- 모든 예외 상황은 `Either.left(Failure.of*())` 형태로만 반환합니다
- 입력 검증 실패: `Either.left(Failure.ofValidation())`
- 리소스 없음: `Either.left(Failure.ofNotFound())`
- 권한 없음: `Either.left(Failure.ofForbidden())`
- 내부 오류: `Either.left(Failure.ofInternalServerError())`

### 3. 외부 호출 처리
- Repository, 외부 API 등에서 예외가 발생할 수 있는 경우 `Try.of()` 또는 `try-catch`로 감싸서 처리
- 발생한 예외를 적절한 `Failure` 타입으로 변환하여 `Either.left`로 반환

## 적용 예시

### ❌ 잘못된 예
```java
public Either<Failure, List<Board>> getUserBoards(GetUserBoardsCommand command) {
    if (command == null) {
        throw new IllegalArgumentException("Command cannot be null"); // 예외 던짐
    }
    
    if (command.ownerId() == null) {
        throw new NullPointerException("Owner ID is required"); // 예외 던짐
    }
    
    return boardRepository.findByOwnerId(command.ownerId()); // 예외 처리 없음
}
```

### ✅ 올바른 예
```java
public Either<Failure, List<Board>> getUserBoards(GetUserBoardsCommand command) {
    // null 체크도 Either.left로 처리
    if (command == null) {
        var violation = Failure.FieldViolation.builder()
                .field("command")
                .message("INVALID_COMMAND")
                .rejectedValue(null)
                .build();
        return Either.left(Failure.ofValidation("입력 데이터가 유효하지 않습니다.", List.of(violation)));
    }
    
    // 비즈니스 검증 실패도 Either.left로 처리
    if (command.ownerId() == null) {
        var violation = Failure.FieldViolation.builder()
                .field("ownerId")
                .message("소유자 ID는 필수입니다.")
                .rejectedValue(null)
                .build();
        return Either.left(Failure.ofValidation("입력 데이터가 유효하지 않습니다.", List.of(violation)));
    }
    
    // 외부 호출 예외를 Either.left로 변환
    return Try.of(() -> boardRepository.findByOwnerId(command.ownerId()))
        .fold(
            throwable -> Either.left(Failure.ofInternalServerError("보드 목록 조회 중 오류가 발생했습니다.")),
            Either::right
        );
}
```

## 적용 범위
- Service 클래스의 모든 public 메서드
- UseCase 인터페이스의 모든 메서드
- Repository 구현체에서 `Either<Failure, T>`를 리턴하는 메서드

## 이점
1. **일관성**: 모든 오류가 동일한 방식으로 처리됨
2. **예측 가능성**: 호출자가 예외 처리를 걱정할 필요 없음
3. **함수형 프로그래밍**: Railway-oriented programming 패턴 적용
4. **테스트 용이성**: 모든 오류 상황을 쉽게 테스트 가능 # Either No Exceptions Rule

## 규칙 이름
`either-no-exceptions`

## 설명
메서드의 리턴 타입이 `Either<Failure, T>`인 경우, 해당 메서드는 **어떤 예외(Exception)도 던지지 않아야** 합니다. `IllegalArgumentException`, `NullPointerException` 등을 포함한 모든 오류 상황은 `Either.left(Failure)`로 처리해야 합니다.

## 세부 규칙

### 1. 예외 금지
- `Either<Failure, T>` 리턴 타입을 가진 메서드는 `throws` 선언을 하지 않습니다
- `throw new Exception()` 구문을 사용하지 않습니다
- `IllegalArgumentException`, `NullPointerException` 등 프로그래밍 오류도 예외로 던지지 않습니다

### 2. 오류 처리 방식
- 모든 예외 상황은 `Either.left(Failure.of*())` 형태로만 반환합니다
- 입력 검증 실패: `Either.left(Failure.ofValidation())`
- 리소스 없음: `Either.left(Failure.ofNotFound())`
- 권한 없음: `Either.left(Failure.ofForbidden())`
- 내부 오류: `Either.left(Failure.ofInternalServerError())`

### 3. 외부 호출 처리
- Repository, 외부 API 등에서 예외가 발생할 수 있는 경우 `Try.of()` 또는 `try-catch`로 감싸서 처리
- 발생한 예외를 적절한 `Failure` 타입으로 변환하여 `Either.left`로 반환

## 적용 예시

### ❌ 잘못된 예
```java
public Either<Failure, List<Board>> getUserBoards(GetUserBoardsCommand command) {
    if (command == null) {
        throw new IllegalArgumentException("Command cannot be null"); // 예외 던짐
    }
    
    if (command.ownerId() == null) {
        throw new NullPointerException("Owner ID is required"); // 예외 던짐
    }
    
    return boardRepository.findByOwnerId(command.ownerId()); // 예외 처리 없음
}
```

### ✅ 올바른 예
```java
public Either<Failure, List<Board>> getUserBoards(GetUserBoardsCommand command) {
    // null 체크도 Either.left로 처리
    if (command == null) {
        var violation = Failure.FieldViolation.builder()
                .field("command")
                .message("명령은 필수입니다.")
                .rejectedValue(null)
                .build();
        return Either.left(Failure.ofValidation("입력 데이터가 유효하지 않습니다.", List.of(violation)));
    }
    
    // 비즈니스 검증 실패도 Either.left로 처리
    if (command.ownerId() == null) {
        var violation = Failure.FieldViolation.builder()
                .field("ownerId")
                .message("소유자 ID는 필수입니다.")
                .rejectedValue(null)
                .build();
        return Either.left(Failure.ofValidation("입력 데이터가 유효하지 않습니다.", List.of(violation)));
    }
    
    // 외부 호출 예외를 Either.left로 변환
    return Try.of(() -> boardRepository.findByOwnerId(command.ownerId()))
        .fold(
            throwable -> Either.left(Failure.ofInternalServerError("보드 목록 조회 중 오류가 발생했습니다.")),
            Either::right
        );
}
```

## 적용 범위
- Service 클래스의 모든 public 메서드
- UseCase 인터페이스의 모든 메서드
- Repository 구현체에서 `Either<Failure, T>`를 리턴하는 메서드

## 이점
1. **일관성**: 모든 오류가 동일한 방식으로 처리됨
2. **예측 가능성**: 호출자가 예외 처리를 걱정할 필요 없음
3. **함수형 프로그래밍**: Railway-oriented programming 패턴 적용
4. **테스트 용이성**: 모든 오류 상황을 쉽게 테스트 가능 